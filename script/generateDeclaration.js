const { writeFileSync } = require('fs');
const path = require('path');
const asyncPool = require('tiny-async-pool');
const axios = require('axios').default;
const { compile } = require('json-schema-to-typescript');
const colors = require('colors/safe');
const log = require('./log');

const service = axios.create({
  baseURL: 'https://open.kwaixiaodian.com',
  headers: {
    'request-source': 'kuaishou-merchant-node-open-api',
    'Referer': 'https://open.kwaixiaodian.com/docs/api',
    'Host': 'open.kwaixiaodian.com',
    'kpf': 'PC_WEB',
    'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.0.0 Safari/537.36'
  },
});

service.interceptors.response.use(res => {
  if (res && res.status === 200 && res.data && res.data.status === 200) return res.data.data;
  return Promise.reject(res);
}, res => res?.response?.data);

const asyncPoolAll = async (...args) => {
  const results = [];
  for await (const result of asyncPool(...args)) {
    results.push(result);
  }
  return results;
}

const MethodEnum = {
  GET: 1,
  POST: 2,
  PUT: 3,
  DELETE: 4,
  HEAD: 5,
  PATCH: 6,
  OPTIONS: 7,
};

const baseComment = `
/* eslint-disable */
/* tslint:disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */
`

class GenerateDeclaration {
  API_DEFAULT_METHOD = {};
  GET_STRUCTURE_CACHE = {};
  STRUCTURE_MAP = {};
  total = 0;
  currentCount = 0;

  isArrayType (paramType = '') {
    const listMatch = /^List<.+>$/i;
    const listMatch2 = /.+\[\]$/;
    return !!(paramType.match(listMatch) || paramType.match(listMatch2));
  }
  replaceArrayType  (paramType = '') {
    const newStr = paramType + '';
    const listMatch = /^List</i;
    const listMatch2 = /(\[\]$)|(>$)/;
    return newStr.replace(listMatch, '')?.replace?.(listMatch2, '')?.replace(/\s/g, '');
  }

  basicTypeConvert (type = '') {
    const lowerCaseType = type.toLocaleLowerCase() || 'unknow';
    let newBasicType = lowerCaseType;
    let tsType;
    if (lowerCaseType === 'number' || lowerCaseType === 'long' || lowerCaseType === 'integer' || lowerCaseType === 'double' || lowerCaseType === 'float') newBasicType = 'number';
    if (lowerCaseType === 'map') {
      newBasicType === 'object';
      tsType = 'Record<string, any>';
    }
    if (lowerCaseType === 'date') {
      newBasicType === 'object';
      tsType = 'Date|number';
    }
    if (lowerCaseType === 'bytes') {
      newBasicType === 'object';
      tsType = 'NodeJS.ReadableStream|Buffer'
    }
    const data = {
      type: newBasicType,
    };
    tsType && (data.tsType = tsType);
    return data;
  }

  getApiList () {
    return service.request({
      url: '/rest/open/platform/doc/api/category/list',
      method: 'GET',
    }).then((data = []) => {
      return data.reduce((pre, current) => {
        return pre.concat(current.items || []);
      }, [])
    })
  }

  getSturcture(params) {
    const id = params.id;
    if (this.GET_STRUCTURE_CACHE[id]) return Promise.resolve(this.GET_STRUCTURE_CACHE[id]);
    return service.request({
      url: '/rest/open/platform/doc/structure/detail',
      method: 'GET',
      params
    }).then((data) => {
      if (data.errorMsg && !data.params) return Promise.reject(data);
      const structureParams = data.params || [];
      this.GET_STRUCTURE_CACHE[id] = structureParams
      return structureParams;
    })
  }

  getSturctureName (name, id) {
    return `${name}_${id}`;
  }

  setStructureMap(name, paramInfo, propertiesInfo) {
    const uniqueKey = this.getSturctureName(name, paramInfo.structureId);
    const savedSturctureInfo = this.STRUCTURE_MAP[uniqueKey] || { properties: {}, required: [] };

    this.STRUCTURE_MAP[uniqueKey] = {
      title: uniqueKey,
      description: paramInfo.description,
      type: 'object',
      ...propertiesInfo,
      properties: {
        ...savedSturctureInfo.properties,
        ...propertiesInfo.properties,
      },
      required: [
        ...savedSturctureInfo.required,
        ...propertiesInfo.required
      ]
    }
  }

  formatParams (params = [], structureLoadedMap = {}) {
    return Promise.resolve(params).then((paramsList) => {
      return paramsList.reduce((pre, current = {}) => {
        const { paramName, paramType, description, structureId, required } = current;
        const isArray = this.isArrayType(paramType);
        const paramTypeWithoutArray = this.replaceArrayType(paramType);
        const isStructure = !!structureId;
        return pre.then(async (res) => {
          if (required) {
            res.required = [...(res.required || []), paramName];
          }

          // 基本类型
          if (!isStructure && !isArray) return {
            properties: {
              ...(res.properties || {}),
              [paramName]: {
                ...this.basicTypeConvert(paramTypeWithoutArray),
                description: description,
              },
            },
            required: res.required,
          }

          let arraySchema = {};
          let structureSchema = {};
          // 基本类型数组
          if (!isStructure) {
            arraySchema = {
              type: 'array',
              items: { ...this.basicTypeConvert(paramTypeWithoutArray) }
            }
          } else {
            log.info(`开始获取结构体${paramTypeWithoutArray}`);
            if (!structureLoadedMap[structureId]) {
              structureLoadedMap[structureId] = true;
              let propertiesInfo = await this.formatParams(this.getSturcture({ id: structureId }).catch(() => {
                log.error(`结构体${paramTypeWithoutArray}获取失败`);
                return Promise.resolve([]);
              }), structureLoadedMap);
              log.success(`结构体${paramTypeWithoutArray}获取成功`);
              this.setStructureMap(paramTypeWithoutArray, current, propertiesInfo);
            }
            const typeWithId = this.getSturctureName(paramTypeWithoutArray, structureId);
            structureSchema = {
              tsType: isArray ? `${typeWithId}[]` : typeWithId
            }
          }
          return {
            properties: {
              ...(res.properties || {}),
              [paramName]: {
                description,
                ...structureSchema,
                ...arraySchema,
              }
            },
            required: res.required,
          }
        })
      }, Promise.resolve({ properties: {}, required: [] }))
    });
  }

  getApiInfo (params) {
    const percent = parseInt((++this.currentCount / this.total) * 10000) / 100;
    console.log('生成进度:', colors.yellow(`${percent}%`));
    console.log('当前参数:', params)
    return service.request({
      url: '/rest/open/platform/doc/api/name/detail',
      method: 'GET',
      params
    }).then(async (data) => {
      const { name, inputParams = [], outputParams = [], cnName, description, method = 1 } = data || {};
      const hasInput = inputParams.length > 0;
      const hasOutput = outputParams.length > 0;
      for (let methodString of Object.keys(MethodEnum)) {
        const methodValue = MethodEnum[methodString];
        if (methodValue === method) {
          this.API_DEFAULT_METHOD[name] = methodString;
        }
      }
      return { name, inputParams: await this.formatParams(inputParams), outputParams: await this.formatParams(outputParams), cnName, description, hasInput, hasOutput };
    })
  }

  async getApiInfoList  () {
    const apiList = (await this.getApiList());
    const params = apiList.map((item) => ({ name: item.name, version: item.version }));
    this.total = params.length;
    log.success(`共${this.total}个API`);
    return asyncPoolAll(4, params, this.getApiInfo.bind(this));
  }

  async declaration (apiListInfo = []) {
    log.success('开始生成declaration');
    const schema = apiListInfo.reduce((pre, current) => {
      const { name, cnName, hasInput, hasOutput, inputParams, outputParams } = current || {};
      pre.required.push(name);
      pre.properties[name] = {
        type: 'object',
        description: cnName,
        properties: {
          request: {
            type: 'object',
            description: 'API入参',
            ...inputParams
          },
          response: {
            type: 'object',
            description: 'API出参',
            ...outputParams
          },
        },
        required: [hasInput && 'request', hasOutput && 'response'].filter(Boolean)
      }
      return pre;
    }, { properties: {}, required: [] });
    const ApiDeclaration = {
      title: 'ApiDeclaration',
      type: 'object',
      description: 'API类型定义',
      additionalProperties: false,
      ...schema
    };
    const declarationList = await Promise.all([...Object.values(this.STRUCTURE_MAP).map((structureDeclaration, index) => compile(structureDeclaration, structureDeclaration.title, { bannerComment: index !== 0 ? '' : baseComment })), compile(ApiDeclaration, ApiDeclaration.title, { bannerComment: ''})]);

    log.success('开始写入declaration');
    writeFileSync(path.join(__dirname, '../packages/common/interface/api.declaration.ts'), declarationList.join(''));
    writeFileSync(path.join(__dirname, '../packages/common/constant/api.default.method.ts'), `export default ${JSON.stringify(this.API_DEFAULT_METHOD)}`);
    log.success('declaration写入成功');
    console.log(`一共${colors.yellow(this.total + '')}个API, 成功${colors.green(this.currentCount)}个, 失败${colors.red(this.total - this.currentCount)}`);
  }

  async start () {
    this.declaration(await this.getApiInfoList())
  }
}

module.exports = new GenerateDeclaration();